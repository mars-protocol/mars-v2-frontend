// @ts-nocheck
/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from '@tanstack/react-query'
import { ExecuteResult } from '@cosmjs/cosmwasm-stargate'
import { StdFee } from '@cosmjs/amino'
import {
  Decimal,
  InstantiateMsg,
  ExecuteMsg,
  OwnerUpdate,
  Uint128,
  Int128,
  ActionKind,
  PerpParams,
  ConfigUpdates,
  QueryMsg,
  ConfigForString,
  SignedDecimal,
  MarketResponse,
  AccountingResponse,
  Accounting,
  Balance,
  CashFlow,
  PnlAmounts,
  Int256,
  Uint256,
  MarketStateResponse,
  Funding,
  PaginationResponseForMarketResponse,
  Metadata,
  TradingFee,
  Coin,
  OwnerResponse,
  PositionResponse,
  PerpPosition,
  PositionFeesResponse,
  ArrayOfPositionResponse,
  PositionsByAccountResponse,
  VaultResponse,
  NullableVaultPositionResponse,
  VaultPositionResponse,
  VaultDeposit,
  VaultUnlock,
} from './MarsPerps.types'
import { MarsPerpsQueryClient, MarsPerpsClient } from './MarsPerps.client'
export const marsPerpsQueryKeys = {
  contract: [
    {
      contract: 'marsPerps',
    },
  ] as const,
  address: (contractAddress: string | undefined) =>
    [
      {
        ...marsPerpsQueryKeys.contract[0],
        address: contractAddress,
      },
    ] as const,
  owner: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'owner',
        args,
      },
    ] as const,
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'config',
        args,
      },
    ] as const,
  vault: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'vault',
        args,
      },
    ] as const,
  marketState: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'market_state',
        args,
      },
    ] as const,
  market: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'market',
        args,
      },
    ] as const,
  markets: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'markets',
        args,
      },
    ] as const,
  vaultPosition: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'vault_position',
        args,
      },
    ] as const,
  position: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'position',
        args,
      },
    ] as const,
  positions: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'positions',
        args,
      },
    ] as const,
  positionsByAccount: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'positions_by_account',
        args,
      },
    ] as const,
  realizedPnlByAccountAndMarket: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>,
  ) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'realized_pnl_by_account_and_market',
        args,
      },
    ] as const,
  marketAccounting: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'market_accounting',
        args,
      },
    ] as const,
  totalAccounting: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'total_accounting',
        args,
      },
    ] as const,
  openingFee: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'opening_fee',
        args,
      },
    ] as const,
  positionFees: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      {
        ...marsPerpsQueryKeys.address(contractAddress)[0],
        method: 'position_fees',
        args,
      },
    ] as const,
}
export interface MarsPerpsReactQuery<TResponse, TData = TResponse> {
  client: MarsPerpsQueryClient | undefined
  options?: Omit<
    UseQueryOptions<TResponse, Error, TData>,
    "'queryKey' | 'queryFn' | 'initialData'"
  > & {
    initialData?: undefined
  }
}
export interface MarsPerpsPositionFeesQuery<TData>
  extends MarsPerpsReactQuery<PositionFeesResponse, TData> {
  args: {
    accountId: string
    denom: string
    newSize: Int128
  }
}
export function useMarsPerpsPositionFeesQuery<TData = PositionFeesResponse>({
  client,
  args,
  options,
}: MarsPerpsPositionFeesQuery<TData>) {
  return useQuery<PositionFeesResponse, Error, TData>(
    marsPerpsQueryKeys.positionFees(client?.contractAddress, args),
    () =>
      client
        ? client.positionFees({
            accountId: args.accountId,
            denom: args.denom,
            newSize: args.newSize,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsOpeningFeeQuery<TData> extends MarsPerpsReactQuery<TradingFee, TData> {
  args: {
    denom: string
    size: Int128
  }
}
export function useMarsPerpsOpeningFeeQuery<TData = TradingFee>({
  client,
  args,
  options,
}: MarsPerpsOpeningFeeQuery<TData>) {
  return useQuery<TradingFee, Error, TData>(
    marsPerpsQueryKeys.openingFee(client?.contractAddress, args),
    () =>
      client
        ? client.openingFee({
            denom: args.denom,
            size: args.size,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsTotalAccountingQuery<TData>
  extends MarsPerpsReactQuery<AccountingResponse, TData> {}
export function useMarsPerpsTotalAccountingQuery<TData = AccountingResponse>({
  client,
  options,
}: MarsPerpsTotalAccountingQuery<TData>) {
  return useQuery<AccountingResponse, Error, TData>(
    marsPerpsQueryKeys.totalAccounting(client?.contractAddress),
    () => (client ? client.totalAccounting() : Promise.reject(new Error('Invalid client'))),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsMarketAccountingQuery<TData>
  extends MarsPerpsReactQuery<AccountingResponse, TData> {
  args: {
    denom: string
  }
}
export function useMarsPerpsMarketAccountingQuery<TData = AccountingResponse>({
  client,
  args,
  options,
}: MarsPerpsMarketAccountingQuery<TData>) {
  return useQuery<AccountingResponse, Error, TData>(
    marsPerpsQueryKeys.marketAccounting(client?.contractAddress, args),
    () =>
      client
        ? client.marketAccounting({
            denom: args.denom,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsRealizedPnlByAccountAndMarketQuery<TData>
  extends MarsPerpsReactQuery<PnlAmounts, TData> {
  args: {
    accountId: string
    denom: string
  }
}
export function useMarsPerpsRealizedPnlByAccountAndMarketQuery<TData = PnlAmounts>({
  client,
  args,
  options,
}: MarsPerpsRealizedPnlByAccountAndMarketQuery<TData>) {
  return useQuery<PnlAmounts, Error, TData>(
    marsPerpsQueryKeys.realizedPnlByAccountAndMarket(client?.contractAddress, args),
    () =>
      client
        ? client.realizedPnlByAccountAndMarket({
            accountId: args.accountId,
            denom: args.denom,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsPositionsByAccountQuery<TData>
  extends MarsPerpsReactQuery<PositionsByAccountResponse, TData> {
  args: {
    accountId: string
    action?: ActionKind
  }
}
export function useMarsPerpsPositionsByAccountQuery<TData = PositionsByAccountResponse>({
  client,
  args,
  options,
}: MarsPerpsPositionsByAccountQuery<TData>) {
  return useQuery<PositionsByAccountResponse, Error, TData>(
    marsPerpsQueryKeys.positionsByAccount(client?.contractAddress, args),
    () =>
      client
        ? client.positionsByAccount({
            accountId: args.accountId,
            action: args.action,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsPositionsQuery<TData>
  extends MarsPerpsReactQuery<ArrayOfPositionResponse, TData> {
  args: {
    limit?: number
    startAfter?: string[][]
  }
}
export function useMarsPerpsPositionsQuery<TData = ArrayOfPositionResponse>({
  client,
  args,
  options,
}: MarsPerpsPositionsQuery<TData>) {
  return useQuery<ArrayOfPositionResponse, Error, TData>(
    marsPerpsQueryKeys.positions(client?.contractAddress, args),
    () =>
      client
        ? client.positions({
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsPositionQuery<TData>
  extends MarsPerpsReactQuery<PositionResponse, TData> {
  args: {
    accountId: string
    denom: string
    orderSize?: Int128
  }
}
export function useMarsPerpsPositionQuery<TData = PositionResponse>({
  client,
  args,
  options,
}: MarsPerpsPositionQuery<TData>) {
  return useQuery<PositionResponse, Error, TData>(
    marsPerpsQueryKeys.position(client?.contractAddress, args),
    () =>
      client
        ? client.position({
            accountId: args.accountId,
            denom: args.denom,
            orderSize: args.orderSize,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsVaultPositionQuery<TData>
  extends MarsPerpsReactQuery<NullableVaultPositionResponse, TData> {
  args: {
    accountId?: string
    userAddress: string
  }
}
export function useMarsPerpsVaultPositionQuery<TData = NullableVaultPositionResponse>({
  client,
  args,
  options,
}: MarsPerpsVaultPositionQuery<TData>) {
  return useQuery<NullableVaultPositionResponse, Error, TData>(
    marsPerpsQueryKeys.vaultPosition(client?.contractAddress, args),
    () =>
      client
        ? client.vaultPosition({
            accountId: args.accountId,
            userAddress: args.userAddress,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsMarketsQuery<TData>
  extends MarsPerpsReactQuery<PaginationResponseForMarketResponse, TData> {
  args: {
    limit?: number
    startAfter?: string
  }
}
export function useMarsPerpsMarketsQuery<TData = PaginationResponseForMarketResponse>({
  client,
  args,
  options,
}: MarsPerpsMarketsQuery<TData>) {
  return useQuery<PaginationResponseForMarketResponse, Error, TData>(
    marsPerpsQueryKeys.markets(client?.contractAddress, args),
    () =>
      client
        ? client.markets({
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsMarketQuery<TData> extends MarsPerpsReactQuery<MarketResponse, TData> {
  args: {
    denom: string
  }
}
export function useMarsPerpsMarketQuery<TData = MarketResponse>({
  client,
  args,
  options,
}: MarsPerpsMarketQuery<TData>) {
  return useQuery<MarketResponse, Error, TData>(
    marsPerpsQueryKeys.market(client?.contractAddress, args),
    () =>
      client
        ? client.market({
            denom: args.denom,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsMarketStateQuery<TData>
  extends MarsPerpsReactQuery<MarketStateResponse, TData> {
  args: {
    denom: string
  }
}
export function useMarsPerpsMarketStateQuery<TData = MarketStateResponse>({
  client,
  args,
  options,
}: MarsPerpsMarketStateQuery<TData>) {
  return useQuery<MarketStateResponse, Error, TData>(
    marsPerpsQueryKeys.marketState(client?.contractAddress, args),
    () =>
      client
        ? client.marketState({
            denom: args.denom,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsVaultQuery<TData> extends MarsPerpsReactQuery<VaultResponse, TData> {
  args: {
    action?: ActionKind
  }
}
export function useMarsPerpsVaultQuery<TData = VaultResponse>({
  client,
  args,
  options,
}: MarsPerpsVaultQuery<TData>) {
  return useQuery<VaultResponse, Error, TData>(
    marsPerpsQueryKeys.vault(client?.contractAddress, args),
    () =>
      client
        ? client.vault({
            action: args.action,
          })
        : Promise.reject(new Error('Invalid client')),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsConfigQuery<TData> extends MarsPerpsReactQuery<ConfigForString, TData> {}
export function useMarsPerpsConfigQuery<TData = ConfigForString>({
  client,
  options,
}: MarsPerpsConfigQuery<TData>) {
  return useQuery<ConfigForString, Error, TData>(
    marsPerpsQueryKeys.config(client?.contractAddress),
    () => (client ? client.config() : Promise.reject(new Error('Invalid client'))),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsOwnerQuery<TData> extends MarsPerpsReactQuery<OwnerResponse, TData> {}
export function useMarsPerpsOwnerQuery<TData = OwnerResponse>({
  client,
  options,
}: MarsPerpsOwnerQuery<TData>) {
  return useQuery<OwnerResponse, Error, TData>(
    marsPerpsQueryKeys.owner(client?.contractAddress),
    () => (client ? client.owner() : Promise.reject(new Error('Invalid client'))),
    {
      ...options,
      enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
    },
  )
}
export interface MarsPerpsUpdateConfigMutation {
  client: MarsPerpsClient
  msg: {
    updates: ConfigUpdates
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useMarsPerpsUpdateConfigMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, MarsPerpsUpdateConfigMutation>,
    'mutationFn'
  >,
) {
  return useMutation<ExecuteResult, Error, MarsPerpsUpdateConfigMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateConfig(msg, fee, memo, funds),
    options,
  )
}
export interface MarsPerpsUpdateMarketMutation {
  client: MarsPerpsClient
  msg: {
    params: PerpParams
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useMarsPerpsUpdateMarketMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, MarsPerpsUpdateMarketMutation>,
    'mutationFn'
  >,
) {
  return useMutation<ExecuteResult, Error, MarsPerpsUpdateMarketMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateMarket(msg, fee, memo, funds),
    options,
  )
}
export interface MarsPerpsDeleverageMutation {
  client: MarsPerpsClient
  msg: {
    accountId: string
    denom: string
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useMarsPerpsDeleverageMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, MarsPerpsDeleverageMutation>,
    'mutationFn'
  >,
) {
  return useMutation<ExecuteResult, Error, MarsPerpsDeleverageMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.deleverage(msg, fee, memo, funds),
    options,
  )
}
export interface MarsPerpsCloseAllPositionsMutation {
  client: MarsPerpsClient
  msg: {
    accountId: string
    action?: ActionKind
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useMarsPerpsCloseAllPositionsMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, MarsPerpsCloseAllPositionsMutation>,
    'mutationFn'
  >,
) {
  return useMutation<ExecuteResult, Error, MarsPerpsCloseAllPositionsMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.closeAllPositions(msg, fee, memo, funds),
    options,
  )
}
export interface MarsPerpsExecuteOrderMutation {
  client: MarsPerpsClient
  msg: {
    accountId: string
    denom: string
    reduceOnly?: boolean
    size: Int128
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useMarsPerpsExecuteOrderMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, MarsPerpsExecuteOrderMutation>,
    'mutationFn'
  >,
) {
  return useMutation<ExecuteResult, Error, MarsPerpsExecuteOrderMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.executeOrder(msg, fee, memo, funds),
    options,
  )
}
export interface MarsPerpsWithdrawMutation {
  client: MarsPerpsClient
  msg: {
    accountId?: string
    minReceive?: Uint128
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useMarsPerpsWithdrawMutation(
  options?: Omit<UseMutationOptions<ExecuteResult, Error, MarsPerpsWithdrawMutation>, 'mutationFn'>,
) {
  return useMutation<ExecuteResult, Error, MarsPerpsWithdrawMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.withdraw(msg, fee, memo, funds),
    options,
  )
}
export interface MarsPerpsUnlockMutation {
  client: MarsPerpsClient
  msg: {
    accountId?: string
    shares: Uint128
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useMarsPerpsUnlockMutation(
  options?: Omit<UseMutationOptions<ExecuteResult, Error, MarsPerpsUnlockMutation>, 'mutationFn'>,
) {
  return useMutation<ExecuteResult, Error, MarsPerpsUnlockMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.unlock(msg, fee, memo, funds),
    options,
  )
}
export interface MarsPerpsDepositMutation {
  client: MarsPerpsClient
  msg: {
    accountId?: string
    maxSharesReceivable?: Uint128
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useMarsPerpsDepositMutation(
  options?: Omit<UseMutationOptions<ExecuteResult, Error, MarsPerpsDepositMutation>, 'mutationFn'>,
) {
  return useMutation<ExecuteResult, Error, MarsPerpsDepositMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.deposit(msg, fee, memo, funds),
    options,
  )
}
export interface MarsPerpsUpdateOwnerMutation {
  client: MarsPerpsClient
  msg: OwnerUpdate
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useMarsPerpsUpdateOwnerMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, MarsPerpsUpdateOwnerMutation>,
    'mutationFn'
  >,
) {
  return useMutation<ExecuteResult, Error, MarsPerpsUpdateOwnerMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.updateOwner(msg, fee, memo, funds),
    options,
  )
}
