// @ts-nocheck
/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.10.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from '@cosmjs/cosmwasm-stargate'
import { StdFee } from '@cosmjs/amino'
import {
  Decimal,
  InstantiateMsg,
  ExecuteMsg,
  OwnerUpdate,
  Uint128,
  ActionKind,
  SignedUint,
  PerpParams,
  ConfigUpdates,
  QueryMsg,
  ConfigForString,
  MarketResponse,
  SignedDecimal,
  AccountingResponse,
  Accounting,
  Balance,
  CashFlow,
  PnlAmounts,
  Uint256,
  MarketStateResponse,
  Funding,
  PaginationResponseForMarketResponse,
  Metadata,
  TradingFee,
  Coin,
  OwnerResponse,
  PositionResponse,
  PerpPosition,
  PositionFeesResponse,
  ArrayOfPositionResponse,
  PositionsByAccountResponse,
  VaultResponse,
  NullableVaultPositionResponse,
  VaultPositionResponse,
  VaultDeposit,
  VaultUnlock,
} from './MarsPerps.types'
export interface MarsPerpsReadOnlyInterface {
  contractAddress: string
  owner: () => Promise<OwnerResponse>
  config: () => Promise<ConfigForString>
  vault: ({ action }: { action?: ActionKind }) => Promise<VaultResponse>
  marketState: ({ denom }: { denom: string }) => Promise<MarketStateResponse>
  market: ({ denom }: { denom: string }) => Promise<MarketResponse>
  markets: ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string
  }) => Promise<PaginationResponseForMarketResponse>
  vaultPosition: ({
    accountId,
    userAddress,
  }: {
    accountId?: string
    userAddress: string
  }) => Promise<NullableVaultPositionResponse>
  position: ({
    accountId,
    denom,
    orderSize,
  }: {
    accountId: string
    denom: string
    orderSize?: SignedUint
  }) => Promise<PositionResponse>
  positions: ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string[][]
  }) => Promise<ArrayOfPositionResponse>
  positionsByAccount: ({
    accountId,
    action,
  }: {
    accountId: string
    action?: ActionKind
  }) => Promise<PositionsByAccountResponse>
  realizedPnlByAccountAndMarket: ({
    accountId,
    denom,
  }: {
    accountId: string
    denom: string
  }) => Promise<PnlAmounts>
  marketAccounting: ({ denom }: { denom: string }) => Promise<AccountingResponse>
  totalAccounting: () => Promise<AccountingResponse>
  openingFee: ({ denom, size }: { denom: string; size: SignedUint }) => Promise<TradingFee>
  positionFees: ({
    accountId,
    denom,
    newSize,
  }: {
    accountId: string
    denom: string
    newSize: SignedUint
  }) => Promise<PositionFeesResponse>
}
export class MarsPerpsQueryClient implements MarsPerpsReadOnlyInterface {
  client: CosmWasmClient
  contractAddress: string
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.owner = this.owner.bind(this)
    this.config = this.config.bind(this)
    this.vault = this.vault.bind(this)
    this.marketState = this.marketState.bind(this)
    this.market = this.market.bind(this)
    this.markets = this.markets.bind(this)
    this.vaultPosition = this.vaultPosition.bind(this)
    this.position = this.position.bind(this)
    this.positions = this.positions.bind(this)
    this.positionsByAccount = this.positionsByAccount.bind(this)
    this.realizedPnlByAccountAndMarket = this.realizedPnlByAccountAndMarket.bind(this)
    this.marketAccounting = this.marketAccounting.bind(this)
    this.totalAccounting = this.totalAccounting.bind(this)
    this.openingFee = this.openingFee.bind(this)
    this.positionFees = this.positionFees.bind(this)
  }
  owner = async (): Promise<OwnerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner: {},
    })
  }
  config = async (): Promise<ConfigForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    })
  }
  vault = async ({ action }: { action?: ActionKind }): Promise<VaultResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      vault: {
        action,
      },
    })
  }
  marketState = async ({ denom }: { denom: string }): Promise<MarketStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      market_state: {
        denom,
      },
    })
  }
  market = async ({ denom }: { denom: string }): Promise<MarketResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      market: {
        denom,
      },
    })
  }
  markets = async ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string
  }): Promise<PaginationResponseForMarketResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      markets: {
        limit,
        start_after: startAfter,
      },
    })
  }
  vaultPosition = async ({
    accountId,
    userAddress,
  }: {
    accountId?: string
    userAddress: string
  }): Promise<NullableVaultPositionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      vault_position: {
        account_id: accountId,
        user_address: userAddress,
      },
    })
  }
  position = async ({
    accountId,
    denom,
    orderSize,
  }: {
    accountId: string
    denom: string
    orderSize?: SignedUint
  }): Promise<PositionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position: {
        account_id: accountId,
        denom,
        order_size: orderSize,
      },
    })
  }
  positions = async ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string[][]
  }): Promise<ArrayOfPositionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      positions: {
        limit,
        start_after: startAfter,
      },
    })
  }
  positionsByAccount = async ({
    accountId,
    action,
  }: {
    accountId: string
    action?: ActionKind
  }): Promise<PositionsByAccountResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      positions_by_account: {
        account_id: accountId,
        action,
      },
    })
  }
  realizedPnlByAccountAndMarket = async ({
    accountId,
    denom,
  }: {
    accountId: string
    denom: string
  }): Promise<PnlAmounts> => {
    return this.client.queryContractSmart(this.contractAddress, {
      realized_pnl_by_account_and_market: {
        account_id: accountId,
        denom,
      },
    })
  }
  marketAccounting = async ({ denom }: { denom: string }): Promise<AccountingResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      market_accounting: {
        denom,
      },
    })
  }
  totalAccounting = async (): Promise<AccountingResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      total_accounting: {},
    })
  }
  openingFee = async ({
    denom,
    size,
  }: {
    denom: string
    size: SignedUint
  }): Promise<TradingFee> => {
    return this.client.queryContractSmart(this.contractAddress, {
      opening_fee: {
        denom,
        size,
      },
    })
  }
  positionFees = async ({
    accountId,
    denom,
    newSize,
  }: {
    accountId: string
    denom: string
    newSize: SignedUint
  }): Promise<PositionFeesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position_fees: {
        account_id: accountId,
        denom,
        new_size: newSize,
      },
    })
  }
}
export interface MarsPerpsInterface extends MarsPerpsReadOnlyInterface {
  contractAddress: string
  sender: string
  updateOwner: (
    ownerUpdate: OwnerUpdate,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  deposit: (
    {
      accountId,
      maxSharesReceivable,
    }: {
      accountId?: string
      maxSharesReceivable?: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  unlock: (
    {
      accountId,
      shares,
    }: {
      accountId?: string
      shares: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  withdraw: (
    {
      accountId,
      minReceive,
    }: {
      accountId?: string
      minReceive?: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  executeOrder: (
    {
      accountId,
      denom,
      reduceOnly,
      size,
    }: {
      accountId: string
      denom: string
      reduceOnly?: boolean
      size: SignedUint
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  closeAllPositions: (
    {
      accountId,
      action,
    }: {
      accountId: string
      action?: ActionKind
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  deleverage: (
    {
      accountId,
      denom,
    }: {
      accountId: string
      denom: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  updateMarket: (
    {
      params,
    }: {
      params: PerpParams
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  updateConfig: (
    {
      updates,
    }: {
      updates: ConfigUpdates
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
}
export class MarsPerpsClient extends MarsPerpsQueryClient implements MarsPerpsInterface {
  client: SigningCosmWasmClient
  sender: string
  contractAddress: string
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.updateOwner = this.updateOwner.bind(this)
    this.deposit = this.deposit.bind(this)
    this.unlock = this.unlock.bind(this)
    this.withdraw = this.withdraw.bind(this)
    this.executeOrder = this.executeOrder.bind(this)
    this.closeAllPositions = this.closeAllPositions.bind(this)
    this.deleverage = this.deleverage.bind(this)
    this.updateMarket = this.updateMarket.bind(this)
    this.updateConfig = this.updateConfig.bind(this)
  }
  updateOwner = async (
    ownerUpdate: OwnerUpdate,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_owner: ownerUpdate,
      },
      fee,
      memo,
      _funds,
    )
  }
  deposit = async (
    {
      accountId,
      maxSharesReceivable,
    }: {
      accountId?: string
      maxSharesReceivable?: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        deposit: {
          account_id: accountId,
          max_shares_receivable: maxSharesReceivable,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  unlock = async (
    {
      accountId,
      shares,
    }: {
      accountId?: string
      shares: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        unlock: {
          account_id: accountId,
          shares,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  withdraw = async (
    {
      accountId,
      minReceive,
    }: {
      accountId?: string
      minReceive?: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        withdraw: {
          account_id: accountId,
          min_receive: minReceive,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  executeOrder = async (
    {
      accountId,
      denom,
      reduceOnly,
      size,
    }: {
      accountId: string
      denom: string
      reduceOnly?: boolean
      size: SignedUint
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        execute_order: {
          account_id: accountId,
          denom,
          reduce_only: reduceOnly,
          size,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  closeAllPositions = async (
    {
      accountId,
      action,
    }: {
      accountId: string
      action?: ActionKind
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        close_all_positions: {
          account_id: accountId,
          action,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  deleverage = async (
    {
      accountId,
      denom,
    }: {
      accountId: string
      denom: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        deleverage: {
          account_id: accountId,
          denom,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  updateMarket = async (
    {
      params,
    }: {
      params: PerpParams
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_market: {
          params,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  updateConfig = async (
    {
      updates,
    }: {
      updates: ConfigUpdates
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_config: {
          updates,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
}
