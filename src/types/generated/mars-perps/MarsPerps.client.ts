// @ts-nocheck
/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from '@cosmjs/cosmwasm-stargate'
import { StdFee } from '@cosmjs/amino'
import {
  OracleBaseForString,
  ParamsBaseForString,
  InstantiateMsg,
  ExecuteMsg,
  OwnerUpdate,
  Decimal,
  Uint128,
  ActionKind,
  SignedUint,
  QueryMsg,
  ConfigForString,
  Accounting,
  Balance,
  CashFlow,
  PnlAmounts,
  DenomStateResponse,
  Funding,
  SignedDecimal,
  ArrayOfDenomStateResponse,
  PerpVaultDeposit,
  TradingFee,
  Coin,
  OwnerResponse,
  PerpDenomState,
  PnlValues,
  NullablePerpVaultPosition,
  PerpVaultPosition,
  PerpVaultUnlock,
  PositionResponse,
  PerpPosition,
  PositionFeesResponse,
  ArrayOfPositionResponse,
  PositionsByAccountResponse,
  ArrayOfPerpVaultUnlock,
  VaultState,
} from './MarsPerps.types'
export interface MarsPerpsReadOnlyInterface {
  contractAddress: string
  owner: () => Promise<OwnerResponse>
  config: () => Promise<ConfigForString>
  vaultState: () => Promise<VaultState>
  denomState: ({ denom }: { denom: string }) => Promise<DenomStateResponse>
  perpDenomState: ({ denom }: { denom: string }) => Promise<PerpDenomState>
  denomStates: ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string
  }) => Promise<ArrayOfDenomStateResponse>
  perpVaultPosition: ({
    accountId,
    action,
    userAddress,
  }: {
    accountId?: string
    action?: ActionKind
    userAddress: string
  }) => Promise<NullablePerpVaultPosition>
  deposit: ({
    accountId,
    userAddress,
  }: {
    accountId?: string
    userAddress: string
  }) => Promise<PerpVaultDeposit>
  unlocks: ({
    accountId,
    userAddress,
  }: {
    accountId?: string
    userAddress: string
  }) => Promise<ArrayOfPerpVaultUnlock>
  position: ({
    accountId,
    denom,
    newSize,
  }: {
    accountId: string
    denom: string
    newSize?: SignedUint
  }) => Promise<PositionResponse>
  positions: ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string[][]
  }) => Promise<ArrayOfPositionResponse>
  positionsByAccount: ({
    accountId,
    action,
  }: {
    accountId: string
    action?: ActionKind
  }) => Promise<PositionsByAccountResponse>
  totalPnl: () => Promise<SignedDecimal>
  openingFee: ({ denom, size }: { denom: string; size: SignedUint }) => Promise<TradingFee>
  denomAccounting: ({ denom }: { denom: string }) => Promise<Accounting>
  totalAccounting: () => Promise<Accounting>
  denomRealizedPnlForAccount: ({
    accountId,
    denom,
  }: {
    accountId: string
    denom: string
  }) => Promise<PnlAmounts>
  positionFees: ({
    accountId,
    denom,
    newSize,
  }: {
    accountId: string
    denom: string
    newSize: SignedUint
  }) => Promise<PositionFeesResponse>
}
export class MarsPerpsQueryClient implements MarsPerpsReadOnlyInterface {
  client: CosmWasmClient
  contractAddress: string

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.owner = this.owner.bind(this)
    this.config = this.config.bind(this)
    this.vaultState = this.vaultState.bind(this)
    this.denomState = this.denomState.bind(this)
    this.perpDenomState = this.perpDenomState.bind(this)
    this.denomStates = this.denomStates.bind(this)
    this.perpVaultPosition = this.perpVaultPosition.bind(this)
    this.deposit = this.deposit.bind(this)
    this.unlocks = this.unlocks.bind(this)
    this.position = this.position.bind(this)
    this.positions = this.positions.bind(this)
    this.positionsByAccount = this.positionsByAccount.bind(this)
    this.totalPnl = this.totalPnl.bind(this)
    this.openingFee = this.openingFee.bind(this)
    this.denomAccounting = this.denomAccounting.bind(this)
    this.totalAccounting = this.totalAccounting.bind(this)
    this.denomRealizedPnlForAccount = this.denomRealizedPnlForAccount.bind(this)
    this.positionFees = this.positionFees.bind(this)
  }

  owner = async (): Promise<OwnerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner: {},
    })
  }
  config = async (): Promise<ConfigForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    })
  }
  vaultState = async (): Promise<VaultState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      vault_state: {},
    })
  }
  denomState = async ({ denom }: { denom: string }): Promise<DenomStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      denom_state: {
        denom,
      },
    })
  }
  perpDenomState = async ({ denom }: { denom: string }): Promise<PerpDenomState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      perp_denom_state: {
        denom,
      },
    })
  }
  denomStates = async ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string
  }): Promise<ArrayOfDenomStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      denom_states: {
        limit,
        start_after: startAfter,
      },
    })
  }
  perpVaultPosition = async ({
    accountId,
    action,
    userAddress,
  }: {
    accountId?: string
    action?: ActionKind
    userAddress: string
  }): Promise<NullablePerpVaultPosition> => {
    return this.client.queryContractSmart(this.contractAddress, {
      perp_vault_position: {
        account_id: accountId,
        action,
        user_address: userAddress,
      },
    })
  }
  deposit = async ({
    accountId,
    userAddress,
  }: {
    accountId?: string
    userAddress: string
  }): Promise<PerpVaultDeposit> => {
    return this.client.queryContractSmart(this.contractAddress, {
      deposit: {
        account_id: accountId,
        user_address: userAddress,
      },
    })
  }
  unlocks = async ({
    accountId,
    userAddress,
  }: {
    accountId?: string
    userAddress: string
  }): Promise<ArrayOfPerpVaultUnlock> => {
    return this.client.queryContractSmart(this.contractAddress, {
      unlocks: {
        account_id: accountId,
        user_address: userAddress,
      },
    })
  }
  position = async ({
    accountId,
    denom,
    newSize,
  }: {
    accountId: string
    denom: string
    newSize?: SignedUint
  }): Promise<PositionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position: {
        account_id: accountId,
        denom,
        new_size: newSize,
      },
    })
  }
  positions = async ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string[][]
  }): Promise<ArrayOfPositionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      positions: {
        limit,
        start_after: startAfter,
      },
    })
  }
  positionsByAccount = async ({
    accountId,
    action,
  }: {
    accountId: string
    action?: ActionKind
  }): Promise<PositionsByAccountResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      positions_by_account: {
        account_id: accountId,
        action,
      },
    })
  }
  totalPnl = async (): Promise<SignedDecimal> => {
    return this.client.queryContractSmart(this.contractAddress, {
      total_pnl: {},
    })
  }
  openingFee = async ({
    denom,
    size,
  }: {
    denom: string
    size: SignedUint
  }): Promise<TradingFee> => {
    return this.client.queryContractSmart(this.contractAddress, {
      opening_fee: {
        denom,
        size,
      },
    })
  }
  denomAccounting = async ({ denom }: { denom: string }): Promise<Accounting> => {
    return this.client.queryContractSmart(this.contractAddress, {
      denom_accounting: {
        denom,
      },
    })
  }
  totalAccounting = async (): Promise<Accounting> => {
    return this.client.queryContractSmart(this.contractAddress, {
      total_accounting: {},
    })
  }
  denomRealizedPnlForAccount = async ({
    accountId,
    denom,
  }: {
    accountId: string
    denom: string
  }): Promise<PnlAmounts> => {
    return this.client.queryContractSmart(this.contractAddress, {
      denom_realized_pnl_for_account: {
        account_id: accountId,
        denom,
      },
    })
  }
  positionFees = async ({
    accountId,
    denom,
    newSize,
  }: {
    accountId: string
    denom: string
    newSize: SignedUint
  }): Promise<PositionFeesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position_fees: {
        account_id: accountId,
        denom,
        new_size: newSize,
      },
    })
  }
}
export interface MarsPerpsInterface extends MarsPerpsReadOnlyInterface {
  contractAddress: string
  sender: string
  updateOwner: (
    ownerUpdate: OwnerUpdate,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  initDenom: (
    {
      denom,
      maxFundingVelocity,
      skewScale,
    }: {
      denom: string
      maxFundingVelocity: Decimal
      skewScale: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  enableDenom: (
    {
      denom,
    }: {
      denom: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  disableDenom: (
    {
      denom,
    }: {
      denom: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  deposit: (
    {
      accountId,
    }: {
      accountId?: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  unlock: (
    {
      accountId,
      shares,
    }: {
      accountId?: string
      shares: Uint128
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  withdraw: (
    {
      accountId,
    }: {
      accountId?: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  openPosition: (
    {
      accountId,
      denom,
      size,
    }: {
      accountId: string
      denom: string
      size: SignedUint
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  closePosition: (
    {
      accountId,
      denom,
    }: {
      accountId: string
      denom: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  modifyPosition: (
    {
      accountId,
      denom,
      newSize,
    }: {
      accountId: string
      denom: string
      newSize: SignedUint
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  closeAllPositions: (
    {
      accountId,
      action,
    }: {
      accountId: string
      action?: ActionKind
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
}
export class MarsPerpsClient extends MarsPerpsQueryClient implements MarsPerpsInterface {
  client: SigningCosmWasmClient
  sender: string
  contractAddress: string

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.updateOwner = this.updateOwner.bind(this)
    this.initDenom = this.initDenom.bind(this)
    this.enableDenom = this.enableDenom.bind(this)
    this.disableDenom = this.disableDenom.bind(this)
    this.deposit = this.deposit.bind(this)
    this.unlock = this.unlock.bind(this)
    this.withdraw = this.withdraw.bind(this)
    this.openPosition = this.openPosition.bind(this)
    this.closePosition = this.closePosition.bind(this)
    this.modifyPosition = this.modifyPosition.bind(this)
    this.closeAllPositions = this.closeAllPositions.bind(this)
  }

  updateOwner = async (
    ownerUpdate: OwnerUpdate,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_owner: ownerUpdate,
      },
      fee,
      memo,
      _funds,
    )
  }
  initDenom = async (
    {
      denom,
      maxFundingVelocity,
      skewScale,
    }: {
      denom: string
      maxFundingVelocity: Decimal
      skewScale: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        init_denom: {
          denom,
          max_funding_velocity: maxFundingVelocity,
          skew_scale: skewScale,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  enableDenom = async (
    {
      denom,
    }: {
      denom: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        enable_denom: {
          denom,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  disableDenom = async (
    {
      denom,
    }: {
      denom: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        disable_denom: {
          denom,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  deposit = async (
    {
      accountId,
    }: {
      accountId?: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        deposit: {
          account_id: accountId,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  unlock = async (
    {
      accountId,
      shares,
    }: {
      accountId?: string
      shares: Uint128
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        unlock: {
          account_id: accountId,
          shares,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  withdraw = async (
    {
      accountId,
    }: {
      accountId?: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        withdraw: {
          account_id: accountId,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  openPosition = async (
    {
      accountId,
      denom,
      size,
    }: {
      accountId: string
      denom: string
      size: SignedUint
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        open_position: {
          account_id: accountId,
          denom,
          size,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  closePosition = async (
    {
      accountId,
      denom,
    }: {
      accountId: string
      denom: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        close_position: {
          account_id: accountId,
          denom,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  modifyPosition = async (
    {
      accountId,
      denom,
      newSize,
    }: {
      accountId: string
      denom: string
      newSize: SignedUint
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        modify_position: {
          account_id: accountId,
          denom,
          new_size: newSize,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  closeAllPositions = async (
    {
      accountId,
      action,
    }: {
      accountId: string
      action?: ActionKind
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        close_all_positions: {
          account_id: accountId,
          action,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
}
